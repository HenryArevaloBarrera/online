<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Detector de emociones amigable</title>
<style>
  body {
    margin:0;
    font-family:'Segoe UI', Roboto, sans-serif;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-start;
    background:#f0f4f8;
    min-height:100vh;
    gap:16px;
    padding:16px;
    transition: background 1s ease;
  }

  h1 {
    color:#6a8caf;
    font-size:2em;
    text-align:center;
  }

  #container {
    position:relative;
    max-width:720px;
    width:100%;
    border-radius:16px;
    overflow:hidden;
    box-shadow:0 8px 20px rgba(0,0,0,0.1);
    background:#fff;
  }

  video, canvas {
    width:100%;
    height:auto;
    display:block;
  }

  #overlayCanvas {
    position:absolute;
    top:0; left:0;
  }

  .controls {
    display:flex;
    gap:12px;
    align-items:center;
    margin-top:8px;
  }

  button {
    padding:10px 18px;
    border:none;
    border-radius:12px;
    background:#6a8caf;
    color:#fff;
    font-weight:bold;
    cursor:pointer;
    transition:0.2s;
    box-shadow:0 4px 8px rgba(0,0,0,0.1);
  }

  button:hover { background:#8bb3d1; }

  .status { font-size:16px; min-width:200px; }

  .note { font-size:14px; color:#555; text-align:center; max-width:600px; }
</style>
</head>
<body>

<h1>Detector de emociones ðŸŽ¨</h1>
<div id="container">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="overlayCanvas"></canvas>
</div>

<div class="controls">
  <div class="status" id="status">Iniciando cÃ¡mara...</div>
  <button id="startBtn">Iniciar</button>
  <button id="stopBtn">Detener</button>
</div>

<div class="note">
  Coloca una tarjeta o color dentro del recuadro central.<br>
  Necesitas HTTPS o localhost para que la cÃ¡mara funcione.
</div>

<script>
const COLOR_WORD_MAP = {
  red: { word:'enojo', face:'ðŸ˜ ', phrase:'Hoy estÃ¡s enojado , respira profundo', bg:'#f28b82' },
  green: { word:'alegrÃ­a', face:'ðŸ˜Š', phrase:'Se te ve alegre , Â¡genial!', bg:'#81c995' },
  blue: { word:'calma', face:'ðŸ˜Œ', phrase:'Hoy estÃ¡s tranquilo , sigue asÃ­', bg:'#a7c7e7' },
  yellow: { word:'energÃ­a', face:'ðŸ˜', phrase:'Se nota tu energÃ­a , Â¡quÃ© bueno!', bg:'#fff475' },
  white: { word:'paz', face:'ðŸ˜‡', phrase:'Hoy estÃ¡s en paz , disfruta el momento', bg:'#ffffff' },
  black: { word:'tristeza', face:'ðŸ˜¢', phrase:'Hoy estÃ¡s triste , Ã¡nimo, todo pasarÃ¡', bg:'#a9a9a9' },
  orange: { word:'entusiasmo', face:'ðŸ¤©', phrase:'Se nota tu entusiasmo , Â¡brillante!', bg:'#f9ab5e' },
  purple: { word:'misterio', face:'ðŸ§', phrase:'Hoy hay un toque de misterio , curioso', bg:'#cba0ff' },
  pink: { word:'cariÃ±o', face:'ðŸ¥°', phrase:'Hoy sientes cariÃ±o, hermoso', bg:'#f7a8b8' }
};

const HSV_RANGES = {
  red: [ [[0,100,50],[10,255,255]], [[160,100,50],[179,255,255]] ],
  green: [ [[35,60,40],[85,255,255]] ],
  blue: [ [[90,50,40],[140,255,255]] ],
  yellow: [ [[20,100,100],[35,255,255]] ],
  white: [ [[0,0,200],[179,40,255]] ],
  black: [ [[0,0,0],[179,255,50]] ],
  orange: [ [[10,100,100],[25,255,255]] ],
  purple: [ [[130,50,50],[160,255,255]] ],
  pink: [ [[160,30,50],[170,255,255]] ]
};

const PERCENT_THRESHOLD = 0.25;
const BOX_W_FRAC = 0.4;
const BOX_H_FRAC = 0.4;

let video = document.getElementById('video');
let overlay = document.getElementById('overlayCanvas');
let statusEl = document.getElementById('status');
let stream = null;
let rafId = null;
let lastDetected = null;
let speaking = false;

// ConversiÃ³n RGB -> HSV
function rgbToHsv(r,g,b){
  r/=255; g/=255; b/=255;
  const mx=Math.max(r,g,b), mn=Math.min(r,g,b), diff=mx-mn;
  let h=0, s=0, v=mx;
  if(diff!==0){
    if(mx===r) h=((g-b)/diff)%6;
    else if(mx===g) h=((b-r)/diff)+2;
    else h=((r-g)/diff)+4;
    h=Math.round(h*60); if(h<0) h+=360;
  }
  s=mx===0?0:diff/mx;
  return [Math.round(h/2), Math.round(s*255), Math.round(v*255)];
}

function inRangeHSV(hsv, low, high){
  const [H,S,V]=hsv;
  return H>=low[0] && H<=high[0] && S>=low[1] && S<=high[1] && V>=low[2] && V<=high[2];
}

// DetecciÃ³n de color
function detectColor(imageData, box){
  const {data,width,height}=imageData;
  const x1=Math.max(0,Math.floor(box.x));
  const y1=Math.max(0,Math.floor(box.y));
  const x2=Math.min(width,Math.floor(box.x+box.w));
  const y2=Math.min(height,Math.floor(box.y+box.h));
  const total=(y2-y1)*(x2-x1);
  if(total<=0) return {color:null, ratio:0};
  const counts={}; for(const c in HSV_RANGES) counts[c]=0;

  for(let yy=y1;yy<y2;yy++){
    for(let xx=x1;xx<x2;xx++){
      const idx=(yy*width+xx)*4;
      const r=data[idx], g=data[idx+1], b=data[idx+2];
      const hsv=rgbToHsv(r,g,b);
      for(const [color,ranges] of Object.entries(HSV_RANGES)){
        for(const rng of ranges){
          const [low,high]=rng;
          if(inRangeHSV(hsv,low,high)){ counts[color]++; break; }
        }
      }
    }
  }

  let best=null, ratio=0;
  for(const [c,count] of Object.entries(counts)){
    const r=count/total;
    if(r>ratio){ ratio=r; best=c; }
  }
  return ratio>=PERCENT_THRESHOLD ? {color:best, ratio} : {color:null, ratio};
}

// Dibujar overlay
function drawOverlay(ctx, box, detected){
  const W=ctx.canvas.width, H=ctx.canvas.height;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle='rgba(255,255,255,0.2)';
  ctx.fillRect(0,0,W,H);
  ctx.clearRect(box.x, box.y, box.w, box.h);
  ctx.strokeStyle='#6a8caf'; ctx.lineWidth=4;
  ctx.strokeRect(box.x, box.y, box.w, box.h);

  ctx.font=`${Math.round(Math.min(W,H)*0.1)}px sans-serif`;
  ctx.textAlign='center'; ctx.textBaseline='middle';
  const face = detected.color && COLOR_WORD_MAP[detected.color]? COLOR_WORD_MAP[detected.color].face:'â“';
  ctx.fillText(face, box.x+box.w/2, box.y+box.h/2);

  ctx.font=`${Math.round(Math.min(W,H)*0.05)}px sans-serif`;
  ctx.fillStyle='#333';
  const label = detected.color ? COLOR_WORD_MAP[detected.color].word : 'DESCONOCIDO';
  ctx.fillText(label, box.x+box.w/2, box.y+box.h+40);
}

// Elegir voz amistosa
function getFriendlyVoice() {
  const voices = window.speechSynthesis.getVoices();
  const friendly = voices.find(v => v.lang.startsWith('es') && v.name.toLowerCase().includes('female'));
  return friendly || voices[0];
}

// Hablar frase
function speakPhrase(text){
  if(!text || speaking) return;
  speaking=true;
  const utter = new SpeechSynthesisUtterance(text);
  utter.voice = getFriendlyVoice();
  utter.lang='es-ES';
  utter.pitch=1.3;
  utter.rate=0.95;
  utter.volume=1.0;
  utter.onend=()=>{ speaking=false; lastDetected=null; };
  window.speechSynthesis.speak(utter);
}

// CÃ¡mara
async function startCamera(){
  try{
    stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
    video.srcObject=stream;
    statusEl.textContent='CÃ¡mara activa';
    await new Promise(r=>video.onloadedmetadata=r);
    overlay.width=video.videoWidth;
    overlay.height=video.videoHeight;
    overlay.style.width=video.clientWidth+'px';
    overlay.style.height=video.clientHeight+'px';
    loop();
  }catch(err){
    console.error(err);
    statusEl.textContent='Error al abrir la cÃ¡mara: '+err.message;
  }
}

function stopCamera(){
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
  if(rafId) cancelAnimationFrame(rafId);
  statusEl.textContent='CÃ¡mara detenida';
}

// Loop de detecciÃ³n
function loop(){
  const ctx=overlay.getContext('2d');
  const tmp=document.createElement('canvas');
  tmp.width=video.videoWidth;
  tmp.height=video.videoHeight;
  const tctx=tmp.getContext('2d');

  function frame(){
    if(!stream) return;
    tctx.drawImage(video,0,0,tmp.width,tmp.height);
    const box_w=Math.round(tmp.width*BOX_W_FRAC);
    const box_h=Math.round(tmp.height*BOX_H_FRAC);
    const box_x=Math.round((tmp.width-box_w)/2);
    const box_y=Math.round((tmp.height-box_h)/2);
    const box={x:box_x,y:box_y,w:box_w,h:box_h};

    const imageData=tctx.getImageData(0,0,tmp.width,tmp.height);
    const detected=detectColor(imageData, box);
    drawOverlay(ctx, box, detected);

    // Cambiar fondo segÃºn emociÃ³n
    if(detected.color && COLOR_WORD_MAP[detected.color]){
      document.body.style.background = COLOR_WORD_MAP[detected.color].bg;
    }

    // Hablar frase
    if(detected.color && !speaking && detected.color!==lastDetected){
      lastDetected=detected.color;
      speakPhrase(COLOR_WORD_MAP[detected.color].phrase);
    }

    rafId=requestAnimationFrame(frame);
  }
  frame();
}

document.getElementById('startBtn').addEventListener('click', ()=>{ if(!stream) startCamera(); });
document.getElementById('stopBtn').addEventListener('click', ()=>stopCamera());
startCamera();
window.addEventListener('beforeunload', stopCamera);
</script>
</body>
</html>

